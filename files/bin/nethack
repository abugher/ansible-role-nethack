#!/bin/bash

                 nethack='/usr/local/games/nethack'
                 version=$(head -n 2 $nethack | tail -n 1 | awk '{print $3}')
         local_bones_dir='/usr/local/games/lib/nethackdir'
             mount_point="/tmp/bones"
        remote_bones_dir="${mount_point}/${version}"
 remote_remote_bones_dir="cryptkeeper@neuronpointer.net:bones"
                lock_dir=".lock_dir"
                 uidfile='/tmp/uidfile'
                 gidfile='/tmp/gidfile'
              remote_uid='995'
              remote_gid='992'
            bones_before='unset'
             bones_after='unset'


function puke {
  ret=$1
  shift
  echo "BLEAH:  ${@}"
  exit $ret
}


mount_remote_bones_dir() {
  login_gid=$( awk -F : "/^$USER:/"' {print $3}' /etc/passwd )
  echo $login_gid | grep -qE '^[0-9]*$' || puke 1 "Invalid login UID:  ${login_uid}"
  login_group=$( awk -F : "/:$login_gid:/"' {print $1}' /etc/passwd )
  echo $login_group | grep -qE '^[a-zA-Z0-9\._][a-zA-Z0-9\._\-]*$' || puke 1 "Invalid login group:  ${login_group}"
  echo "${USER}:${remote_uid}" > $uidfile
  echo "${login_group}:${remote_gid}" > $gidfile
  fusermount -u $mount_point 2>&1 >/dev/null
  fusermount_ret=$?
  if mountpoint $mount_point > /dev/null; then
    puke $fusermount_ret "Failed to unmount:  ${mount_point}"
  fi
  mkdir -p $mount_point || puke $? "Failed to mkdir:  ${mount_point}"
  sshfs \
    -o idmap=file,uidfile=$uidfile,gidfile=$gidfile,reconnect \
    $remote_remote_bones_dir $mount_point || puke $? "Failed to mount:  ${mount_point}"
}


lock_dir() {
  dir="${1}"
  while ! test -f $dir/$lock_dir/pid.$$; do
    while ! mkdir $dir/$lock_dir > /dev/null 2>&1; do
      echo "Waiting for lock on:  ${dir}  (Ctrl C to give up.)"
      for pid_file in $dir/$lock_dir/pid.*; do
        pid=$(sed 's/.*\.//g' <<< $pid_file)
        read user < $pid_file
        echo "Lock held by ${user} for PID:  ${pid}"
      done
      sleep 1
      if rmdir $dir/$lock_dir > /dev/null 2>&1; then
        continue
      fi
    done

    echo $USER@$HOSTNAME > $dir/$lock_dir/pid.$$
  done

  echo "Locked:  ${dir}"
}


unlock_dir() {
  dir="${1}"
  rm $dir/$lock_dir/pid.$$ || puke $? "Failed to remove PID file."
  rmdir $dir/$lock_dir || puke $? "Failed to remove lock file."
  echo "Unlocked:  ${dir}"
}


upload_bones_files() {
  lock_dir $remote_bones_dir
  lock_dir $local_bones_dir
  mkdir -p "${remote_bones_dir}" || puke $? "Failed to create shared bones directory:  ${remote_bones_dir}"
  for bones_file in $(ls $local_bones_dir | grep '^bon') ; do
    bones_file=$(echo $bones_file | sed 's/.*\///g')
    mv $local_bones_dir/$bones_file $remote_bones_dir/$bones_file || puke $? "Failed to move:  ${bones_file}"
    echo "Uploaded: ${bones_file}"
  done
  unlock_dir $local_bones_dir
  unlock_dir $remote_bones_dir
}


download_bones_files() {
  lock_dir $remote_bones_dir
  lock_dir $local_bones_dir
  available_count=$(ls $remote_bones_dir | grep ^bon | wc -l)
  download_quota=$(( $available_count / 2 ))
  if test 1 -eq $available_count; then
    download_quota=1
  fi

  download_count=0
  for bones_file in $(ls $remote_bones_dir | grep ^bon | sort -R); do
    if test $download_count -ge $download_quota; then break; fi
    mv $remote_bones_dir/$bones_file $local_bones_dir/$bones_file || puke $? "failed to move ${bones_file}"
    echo "Downloaded: ${bones_file}"
    let download_count++
  done
  unlock_dir $local_bones_dir
  unlock_dir $remote_bones_dir
}


play() {
  lock_dir $local_bones_dir
  bones_before=$(ls -1 $local_bones_dir/ 2>/dev/null | grep ^bon)

  echo "Starting nethack."
  $nethack

  echo "nethack returned:  $?"

  bones_after=$(ls -1 $local_bones_dir/ 2>/dev/null | grep ^bon)
  unlock_dir $local_bones_dir
}


mount_remote_bones_dir
upload_bones_files
download_bones_files
play
upload_bones_files
