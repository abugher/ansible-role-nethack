#!/bin/bash
                 nethack='/usr/local/games/nethack'
                 version=$(head -n 2 $nethack | tail -n 1 | awk '{print $3}')
              nethackdir='/usr/local/games/lib/nethackdir'
          bones_registry="${nethackdir}/.bones_registry.${USER}"
        remote_bones_dir="/tmp/bones"
             version_dir="${remote_bones_dir}/${version}"
        remote_bones_url="cryptkeeper@neuronpointer.net:bones"
                lock_dir=".lock_dir"
                 uidfile="/tmp/nethack_bones_uidfile.${USER}"
                 gidfile="/tmp/nethack_bones_gidfile.${USER}"
              remote_uid='995'
              remote_gid='992'
             bones_files=()
            lock_timeout=10
             upload_pass=0
                   locks=()
    puke_recursion_count=0
         self_short_name="$(sed 's/^.*\///g' <<< "${0}")"


puke() {
  puke_recursion_count=$(( puke_recursion_count + 1 ))
  ret=$1
  shift
  if test 1 -eq $puke_recursion_count; then
    echo "BLEAH:  ${@}"
    for lock in "${locks[@]}"; do
      unlock $lock
    done
  else
    echo "DOUBLE BLEAH:  ${@}"
  fi
  exit $ret
}


mount_remote_bones_dir() {
  echo "${USER}:${remote_uid}" > $uidfile
  echo "games:${remote_gid}" > $gidfile
  mkdir -p $remote_bones_dir || puke $? "Failed to mkdir:  ${remote_bones_dir}"
  if ! mountpoint $remote_bones_dir > /dev/null; then
#    chown :games $remote_bones_dir || puke $? "Failed to set group ownership on mount point for remote shared bones."
    sshfs \
      -o idmap=file,uidfile=$uidfile,gidfile=$gidfile,allow_other,reconnect \
      $remote_bones_url $remote_bones_dir || puke $? "Failed to mount:  ${remote_bones_dir}"
  fi
}


unmount_remote_bones_dir() {
  fusermount -u $remote_bones_dir || puke $? "Failed to unmount remote shared bones."
  rmdir $remote_bones_dir || puke $? "Failed to remove mount point for remote shared bones."
}


lock() {
  kick_lock "${1}"
  file_lock_dir="${1}"
  i=0
  while ! test -f $file_lock_dir/pid.$$; do
    while ! mkdir $file_lock_dir > /dev/null 2>&1; do
      if rmdir $file_lock_dir > /dev/null 2>&1; then
        continue
      fi
      if test $i -ge $lock_timeout; then
        puke $? "Failed to acquire lock:  $file_lock_dir"
      fi
      sleep 1
      i=$((i+1))
    done
    echo "${USER}@${HOSTNAME}" > $file_lock_dir/pid.$$
  done
  locks+=( $file_lock_dir )
}


kick_lock() {
  file_lock_dir="${1}"
  for pid_file in ${file_lock_dir}/pid.*; do
    pid="$(sed 's/.*\.//g' <<< $pid_file)"
    if test '*' == "${pid}"; then
      continue
    fi
    read user host <<< $(sed 's/@/ /' $pid_file)
    echo "Lock held by ${user} on ${host} for process ${pid} in lock file:  ${file_lock_dir}"
    if test "${HOSTNAME}" = "${host}"; then
      if ! ps -p "${pid}" >/dev/null 2>&1; then
        rm "${pid_file}"
      fi
    fi
  done
  rmdir "${file_lock_dir}" > /dev/null 2>&1
}


lock_dir() {
  dir="${1}"
  lock "${dir}/${lock_dir}"
}


kick_lock_dir() {
  dir="${1}"
  kick_lock "${dir}/${lock_dir}"
}


unlock() {
  file_lock_dir="${1}"
  rm "${file_lock_dir}/pid.${$}" || puke $? "Failed to remove PID file:  ${file_lock_dir}/pid.${$}"
  rmdir "${file_lock_dir}" || puke $? "Failed to remove lock dir:  ${file_lock_dir}"
  locks_backup=("${locks[@]}")
  locks=()
  for lock in "${locks_backup[@]}"; do
    if ! test "${file_lock_dir}" == "${lock}"; then
      locks+=( $lock )
    fi
  done
}


unlock_dir() {
  dir="${1}"
  unlock "${dir}/${lock_dir}"
}


lock_file() {
  file="${1}"
  file_lock_dir=$(sed -E 's/\/([^\/]*)$/\/.lock.\1/' <<< $file)
  lock $file_lock_dir
}


kick_lock_file() {
  file="${1}"
  file_lock_dir=$(sed -E 's/\/([^\/]*)$/\/.lock.\1/' <<< $file)
  kick_lock $file_lock_dir
}


unlock_file() {
  file="${1}"
  unlock $(sed -E 's/\/([^\/]*)$/\/.lock.\1/' <<< $file)
}


file_is_locked() {
  file="${1}"
  file_lock_dir=$(sed -E 's/\/([^\/]*)$/\/.lock.\1/' <<< $file)
  test -d $file_lock_dir
}


unlock_local_bones_files() {
  for bones_file in "${bones_files[@]}"; do
    unlock_file $nethackdir/$bones_file
  done
}


upload_bones_files() {
  upload_pass=$(( upload_pass + 1 ))
  touch $bones_registry || puke $? "Failed to touch bones registry:  ${bones_registry}"
  lock_dir $version_dir
  mkdir -p "${version_dir}" || puke $? "Failed to create shared bones directory:  ${version_dir}"
  oldpwd=$PWD
  for bones_file in "${bones_files[@]}"; do
    kick_lock_file "${nethackdir}/${bones_file}"
    if ! file_is_locked "${nethackdir}/${bones_file}"; then
      if test -e $nethackdir/$bones_file; then
        mv $nethackdir/$bones_file $version_dir/$bones_file || puke $? "Failed to move:  ${bones_file}"
      else
        lock_file $bones_registry
        bones_entry=$(grep " - ${bones_file}\$" $bones_registry)
        echo "       Consumed:  ${bones_entry}"
        > "${bones_registry}.tmp" || puke $? "Failed to create/blank temporary file:  ${bones_registry}.tmp"
        # Don't fail if grep fails.  The bones registry may be empty.
        grep -v " - ${bones_file}\$" $bones_registry > "${bones_registry}.tmp"
        mv $bones_registry.tmp $bones_registry || puke $? "Failed to overwrite bones registry."
        unlock_file $bones_registry
      fi
      echo "        Uploaded: $(stat -c %y "${version_dir}/${bones_file}") - ${bones_file}" 
    else
      echo "Skipped (locked):  ${bones_file}"
    fi
  done
  for bones_file in $(ls $nethackdir | grep '^bon'); do
    kick_lock_file "${nethackdir}/${bones_file}"
    bones_file=$(echo $bones_file | sed 's/.*\///g')
    bones_entry="$(stat -c %y "${nethackdir}/${bones_file}") - ${bones_file}"
    if ! file_is_locked $nethackdir/$bones_file; then
      mv $nethackdir/$bones_file $version_dir/$bones_file || puke $? "Failed to move:  ${bones_file}"
      if test $upload_pass -gt 1; then
        echo "             New: ${bones_entry}"
        lock_file $bones_registry
        if grep -q " - ${bones_file}\$" $bones_registry; then
          overwritten_bones_entry=$(grep " - ${bones_file}\$" $bones_registry)
          echo "    Overwriting:  ${overwritten_bones_entry}"
          > "${bones_registry}.tmp" || puke $? "Failed to create/blank temporary file:  ${bones_registry}.tmp"
          # Don't fail if grep fails.  The bones registry may be empty.
          grep -v " - ${bones_file}\$" $bones_registry > "${bones_registry}.tmp"
          mv $bones_registry.tmp $bones_registry || puke $? "Failed to overwrite bones registry."
        fi
        echo "${bones_entry}" >> $bones_registry
        unlock_file $bones_registry
      else
        echo "        Salvaged: ${bones_entry}"
      fi
    else
      echo "Skipped (locked):  ${bones_file}"
    fi
  done
  unlock_dir $version_dir
}


download_bones_files() {
  lock_dir $version_dir
  available_count=$(ls $version_dir | grep ^bon | wc -l)
  download_quota=$(( $available_count / 2 ))
  if test 1 -eq $available_count; then
    download_quota=1
  fi

  touch $bones_registry || puke $? "Failed to touch bones registry:  ${bones_registry}"

  oldpwd=$PWD
  cd $nethackdir/
  download_count=0
  for bones_file in $(ls $version_dir | grep ^bon | sort -R); do
    if test $download_count -ge $download_quota; then 
      break
    fi
    if 
      ! test -z "${NETHACK_SKIP_SELF_BONES:+isset}" \
      && grep -q " - ${bones_file}\$" $bones_registry
    then 
      continue
    fi
    bones_files+=( $bones_file )
    # Eliminate precision past the second to avoid disagreements about how many
    # decimal places of precision are kept, and subsequent comparison errors.
    # How many bones files can you generate per second, anyway?
    bones_entry="$(stat -c %y "${version_dir}/${bones_file}" | sed 's/\.[0-9]*//') - ${bones_file}"
    lock_file $nethackdir/$bones_file
    mv $version_dir/$bones_file $nethackdir/$bones_file || puke $? "failed to move ${bones_file}"
    echo "      Downloaded: $(stat -c %y "${nethackdir}/${bones_file}") - ${bones_file}"
    let download_count++
  done
  cd -
  unlock_dir $version_dir
}


play() {
  mount_remote_bones_dir
  lock_dir $remote_bones_dir
  upload_bones_files
  download_bones_files
  unlock_dir $remote_bones_dir
  unmount_remote_bones_dir
  echo "Starting nethack."
  $nethack
  echo "nethack returned:  $?"
  unlock_local_bones_files
  mount_remote_bones_dir
  lock_dir $remote_bones_dir
  upload_bones_files
  unlock_dir $remote_bones_dir
  unmount_remote_bones_dir
}


recover() {
  if pgrep -lu "${USER}" nethack; then
    puke 1 "Attempted to recover while a game is active."
  fi
  bases=(
    $(
      find "${nethackdir}" -user "${USER}" \
      | sed 's/^.*\///g' \
      | grep -v '^\.' \
      | grep lock \
      | sed 's/\..*$//' \
      | uniq
    )
  )
  if test 0 -lt "${#bases[@]}"; then
    echo "Recovering games - base names:"
    for base in "${bases[@]}"; do
      echo "  '${base}'"
    done
    "${nethackdir}"/recover -d "${nethackdir}" "${bases[@]}"
    echo "Recovery finished.  Results not checked."
  else
    echo "No games to recover."
  fi
  for base in "${bases[@]}"; do
    echo "Adjusting permissions for:  '${base}'"
    chown :games "${nethackdir}"/"${base}"
  done
}


case "${self_short_name}" in
  nethack)
    play
    ;;
  recover)
    recover
    ;;
  *)
    puke 1 "I don't know how to be '${self_short_name}'.  I'm more of a nethack kind of script."
esac
